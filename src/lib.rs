use serde::{Deserialize, Serialize};
use std::collections::HashSet;

// Module registry structure
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ModuleRegistry {
    pub modules: Vec<Module>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Module {
    pub name: String,
    pub path: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ModuleStatus {
    pub name: String,
    pub path: String,
    pub enabled: bool,
}

/// Verify that all modules exist in the registry
///
/// Returns true if all modules exist, false otherwise
#[must_use]
pub fn verify_modules_exist(modules: &[String], registry: &ModuleRegistry) -> bool {
    let available_modules: HashSet<_> = registry.modules.iter().map(|m| &m.name).collect();

    for module in modules {
        if !available_modules.contains(module) {
            return false;
        }
    }

    true
}

/// Get module path from the registry
#[must_use]
pub fn get_module_path(module_name: &str, registry: &ModuleRegistry) -> Option<String> {
    for module in &registry.modules {
        if module.name == module_name {
            return Some(module.path.clone());
        }
    }

    None
}

/// Check if a module is enabled in the given content
#[must_use]
pub fn is_module_enabled_in_content(module_name: &str, content: &str) -> bool {
    // Look for lines matching the store path pattern ending with "# module_name"
    for line in content.lines() {
        let line = line.trim();
        // Check if this is a store path line and ends with the exact module name
        if line.contains("/nix/store/")
            && line.contains("-source/")
            && line.ends_with(&format!("# {module_name}"))
        {
            return true;
        }
    }

    false
}

/// Get list of all active modules from content
#[must_use]
pub fn get_active_modules_from_content(content: &str) -> Vec<String> {
    let mut active_modules = Vec::new();

    // Extract module names from nix store path lines
    for line in content.lines() {
        let line = line.trim();
        // Only process lines that match our store path pattern
        if line.contains("/nix/store/") && line.contains("-source/") {
            if let Some(comment_pos) = line.find('#') {
                let comment_part = &line[comment_pos + 1..];
                let module_name = comment_part.trim();

                if !module_name.is_empty() {
                    active_modules.push(module_name.to_string());
                }
            }
        }
    }

    active_modules
}

/// Generate modules file content with the specified modules
#[must_use]
pub fn generate_modules_file_content(
    modules: &[String],
    module_paths: &[(String, String)],
) -> String {
    let mut content = String::from("# This file is generated by runtime-module script\n");
    content.push_str("{ ... }:\n");
    content.push_str("{\n");

    if modules.is_empty() {
        content.push_str("  # No active modules\n");
    } else {
        content.push_str("  imports = [\n");

        // Add each module path
        for module in modules {
            // Find path for this module
            if let Some((_, path)) = module_paths.iter().find(|(name, _)| name == module) {
                content.push_str(&format!("    \"{path}\" # {module}\n"));
            }
        }

        content.push_str("  ];\n");
    }

    content.push_str("}\n");

    content
}
