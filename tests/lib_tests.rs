#[cfg(test)]
mod tests {
    use runtime_module::{
        generate_modules_file_content, get_active_modules_from_content, get_module_path,
        is_module_enabled_in_content, verify_modules_exist, Module, ModuleRegistry,
    };

    // Helper to create a test registry
    fn create_test_registry() -> ModuleRegistry {
        ModuleRegistry {
            modules: vec![
                Module {
                    name: "test1".to_string(),
                    path: "/path/to/test1".to_string(),
                },
                Module {
                    name: "test2".to_string(),
                    path: "/path/to/test2".to_string(),
                },
                Module {
                    name: "test3".to_string(),
                    path: "/path/to/test3".to_string(),
                },
            ],
        }
    }

    // Sample modules file content for testing
    fn sample_modules_content() -> String {
        r#"# This file is generated by runtime-module script
{ ... }:
{
  imports = [
    "/nix/store/abcdef-source/path/to/module1" # module1
    "/nix/store/ghijkl-source/path/to/module2" # module2
  ];
}
"#
        .to_string()
    }

    #[test]
    fn test_verify_modules_exist() {
        let registry = create_test_registry();

        // All modules exist
        assert!(verify_modules_exist(
            &["test1".to_string(), "test2".to_string()],
            &registry
        ));

        // Some modules don't exist
        assert!(!verify_modules_exist(
            &["test1".to_string(), "nonexistent".to_string()],
            &registry
        ));

        // Empty list should return true
        assert!(verify_modules_exist(&[], &registry));
    }

    #[test]
    fn test_get_module_path() {
        let registry = create_test_registry();

        // Module exists
        assert_eq!(
            get_module_path("test1", &registry),
            Some("/path/to/test1".to_string())
        );

        // Module doesn't exist
        assert_eq!(get_module_path("nonexistent", &registry), None);
    }

    #[test]
    fn test_is_module_enabled_in_content() {
        let content = sample_modules_content();

        // Module is enabled
        assert!(is_module_enabled_in_content("module1", &content));
        assert!(is_module_enabled_in_content("module2", &content));

        // Module is not enabled
        assert!(!is_module_enabled_in_content("module3", &content));

        // Empty content
        assert!(!is_module_enabled_in_content("module1", ""));
    }

    #[test]
    fn test_get_active_modules_from_content() {
        let content = sample_modules_content();

        let active_modules = get_active_modules_from_content(&content);
        assert_eq!(active_modules.len(), 2);
        assert!(active_modules.contains(&"module1".to_string()));
        assert!(active_modules.contains(&"module2".to_string()));

        // Empty content
        let empty_modules = get_active_modules_from_content("");
        assert!(empty_modules.is_empty());
    }

    #[test]
    fn test_generate_modules_file_content() {
        let modules = vec!["test1".to_string(), "test2".to_string()];
        let module_paths = vec![
            ("test1".to_string(), "/path/to/test1".to_string()),
            ("test2".to_string(), "/path/to/test2".to_string()),
        ];

        let content = generate_modules_file_content(&modules, &module_paths);

        // Check that the content contains the expected module paths
        assert!(content.contains("/path/to/test1"));
        assert!(content.contains("# test1"));
        assert!(content.contains("/path/to/test2"));
        assert!(content.contains("# test2"));

        // Test with empty modules list
        let empty_content = generate_modules_file_content(&[], &module_paths);
        assert!(empty_content.contains("# No active modules"));
    }
}
