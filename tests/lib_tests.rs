#[cfg(test)]
mod tests {
    use runtime_module::{Module, ModuleError, ModuleFile, ModuleRegistry};
    use std::io::{self, Write};
    use tempfile::NamedTempFile;

    // Helper to create a test registry
    fn create_test_registry() -> ModuleRegistry {
        let modules = vec![
            Module {
                name: "test1".to_string(),
                path: "/path/to/test1".to_string(),
                desc: String::new(),
            },
            Module {
                name: "test2".to_string(),
                path: "/path/to/test2".to_string(),
                desc: String::new(),
            },
            Module {
                name: "test3".to_string(),
                path: "/path/to/test3".to_string(),
                desc: String::new(),
            },
        ];

        let mut registry = ModuleRegistry::new(modules);
        registry.init_lookup();
        registry
    }

    // Test error construction and formatting
    #[test]
    fn test_module_error() {
        let io_err = io::Error::new(io::ErrorKind::NotFound, "file not found");
        let module_err = ModuleError::from(io_err);

        assert!(module_err.to_string().contains("IO error"));

        let parse_err = ModuleError::ParseError("Invalid JSON".to_string());
        assert!(parse_err.to_string().contains("Parse error"));

        let not_found_err = ModuleError::ModuleNotFound("missing".to_string());
        assert!(not_found_err.to_string().contains("Module not found"));
    }

    // Test registry initialization
    #[test]
    fn test_registry_init_lookup() {
        let modules = vec![
            Module {
                name: "test1".to_string(),
                path: "/path/to/test1".to_string(),
                desc: String::new(),
            },
            Module {
                name: "test2".to_string(),
                path: "/path/to/test2".to_string(),
                desc: String::new(),
            },
        ];

        let mut registry = ModuleRegistry::new(modules);

        // Before init, module_map should be None
        assert!(!registry.has_lookup_map());

        registry.init_lookup();

        // After init, module_map should contain both modules
        assert!(registry.has_lookup_map());
        if let Some(map) = registry.get_lookup_map() {
            assert_eq!(map.len(), 2);
            assert_eq!(map.get("test1"), Some(&"/path/to/test1".to_string()));
            assert_eq!(map.get("test2"), Some(&"/path/to/test2".to_string()));
        }
    }

    // Test loading registry from a file
    #[test]
    fn test_registry_from_file() -> Result<(), Box<dyn std::error::Error>> {
        let mut temp_file = NamedTempFile::new()?;
        let json_content = r#"
        {
            "modules": [
                {"name": "test1", "path": "/path/to/test1"},
                {"name": "test2", "path": "/path/to/test2"}
            ]
        }
        "#;

        write!(temp_file, "{}", json_content)?;

        let registry = ModuleRegistry::from_file(temp_file.path())?;

        assert_eq!(registry.modules.len(), 2);
        assert_eq!(registry.modules[0].name, "test1");
        assert_eq!(registry.modules[1].path, "/path/to/test2");

        // Verify lookup was initialized
        assert!(registry.has_lookup_map());

        Ok(())
    }

    // Test loading ModuleFile from file
    #[test]
    fn test_module_file_from_file() -> Result<(), Box<dyn std::error::Error>> {
        let mut temp_file = NamedTempFile::new()?;
        let nix_content = r#"# This file is generated by runtime-module script
{ ... }:
{
  imports = [
    "/nix/store/abcdef-source/path/to/module1" # test1
    "/nix/store/ghijkl-source/path/to/module2" # test2
  ];
}
"#;

        write!(temp_file, "{}", nix_content)?;

        let module_file = ModuleFile::from_file(temp_file.path())?;

        assert_eq!(module_file.active_modules.len(), 2);
        assert!(module_file.active_modules.contains(&"test1".to_string()));
        assert!(module_file.active_modules.contains(&"test2".to_string()));

        Ok(())
    }

    // Test parsing edge cases
    #[test]
    fn test_parsing_edge_cases() {
        // Test with empty content
        let empty_modules = ModuleFile::parse_active_modules("");
        assert!(empty_modules.is_empty());

        // Test with no store paths
        let no_store_paths =
            ModuleFile::parse_active_modules("some random content\nwith no store paths");
        assert!(no_store_paths.is_empty());

        // Test with store path but no module comment
        let no_comment = ModuleFile::parse_active_modules(
            "/nix/store/abcdef-source/path/to/module1\n", // No comment
        );
        assert!(no_comment.is_empty());

        // Test with store path but empty comment
        let empty_comment = ModuleFile::parse_active_modules(
            "/nix/store/abcdef-source/path/to/module1 # \n", // Empty comment
        );
        assert!(empty_comment.is_empty());

        // Test with unusual formatting but valid content
        let unusual_format =
            ModuleFile::parse_active_modules("   /nix/store/abcdef-source/path   #   test1   \n");
        assert_eq!(unusual_format.len(), 1);
        assert_eq!(unusual_format[0], "test1");
    }

    // Property-based test: enabling then disabling should restore original state
    #[test]
    fn test_enable_disable_property() {
        let mut module_file = ModuleFile::empty();

        // Enable a module
        module_file.enable_modules(&["test1".to_string()]);
        assert!(module_file.is_module_enabled("test1"));

        // Disable the same module
        module_file.disable_modules(&["test1".to_string()]);
        assert!(!module_file.is_module_enabled("test1"));
        assert_eq!(module_file.active_modules.len(), 0);

        // Enable multiple modules
        module_file.enable_modules(&["test1".to_string(), "test2".to_string()]);
        assert!(module_file.is_module_enabled("test1"));
        assert!(module_file.is_module_enabled("test2"));

        // Disable in reverse order
        module_file.disable_modules(&["test2".to_string()]);
        assert!(module_file.is_module_enabled("test1"));
        assert!(!module_file.is_module_enabled("test2"));

        module_file.disable_modules(&["test1".to_string()]);
        assert!(!module_file.is_module_enabled("test1"));
        assert_eq!(module_file.active_modules.len(), 0);
    }

    // Test multiple operations sequence
    #[test]
    fn test_multiple_operations() {
        let mut module_file = ModuleFile::empty();
        let registry = create_test_registry();

        // Enable some modules
        module_file.enable_modules(&["test1".to_string(), "test2".to_string()]);
        assert_eq!(module_file.active_modules.len(), 2);

        // Generate content
        let content = module_file.generate_content(&registry);
        assert!(content.contains("test1"));
        assert!(content.contains("test2"));

        // Disable one module
        module_file.disable_modules(&["test1".to_string()]);
        assert_eq!(module_file.active_modules.len(), 1);

        // Generate updated content
        let updated_content = module_file.generate_content(&registry);
        assert!(!updated_content.contains("# test1\n"));
        assert!(updated_content.contains("# test2\n"));

        // Enable a different module
        module_file.enable_modules(&["test3".to_string()]);
        assert_eq!(module_file.active_modules.len(), 2);

        // Final content should have test2 and test3
        let final_content = module_file.generate_content(&registry);
        assert!(final_content.contains("# test2\n"));
        assert!(final_content.contains("# test3\n"));
    }

    // Test behavior with duplicate module names
    #[test]
    fn test_duplicate_modules() {
        let mut module_file = ModuleFile::empty();

        // Enable a module multiple times
        module_file.enable_modules(&["test1".to_string()]);
        let first_result = module_file.enable_modules(&["test1".to_string()]);

        // Should return false (no changes) on second attempt
        assert!(!first_result);
        assert_eq!(module_file.active_modules.len(), 1);

        // Enable multiple with duplicates
        let multi_result = module_file.enable_modules(&["test1".to_string(), "test2".to_string()]);

        // Should return true (changes made) because test2 was added
        assert!(multi_result);
        assert_eq!(module_file.active_modules.len(), 2);

        // Try duplicate in the same list
        let dup_list_result =
            module_file.enable_modules(&["test3".to_string(), "test3".to_string()]);

        // Should only add test3 once
        assert!(dup_list_result);
        assert_eq!(module_file.active_modules.len(), 3);

        // Count occurrences of test3
        let test3_count = module_file
            .active_modules
            .iter()
            .filter(|&name| name == "test3")
            .count();
        assert_eq!(test3_count, 1);
    }
}
